using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Caching.Memory;
using Microsoft.Extensions.Logging;
using System;
using System.Collections.Generic;
using System.Linq;
using System.Threading;
using System.Threading.Tasks;
using TaskList.Models;

namespace TaskList.Controllers
{
    // Once we support multiple users, we will need to make
    // sure that these APIs are only exposed to authorized users
    // [Authorize]

    // Note that conventional routing is used for our view-serving controllers,
    // but it is common practice to use attribute-based routing (which is more verbose
    // but offers finer control) for REST/API routing.
    [Route("api/[controller]")]
    public class TasksController: Controller
    {
        private readonly TasksContext DbContext;
        private readonly ILogger Logger;

        public TasksController(TasksContext dbContext, ILogger<TasksController> logger)
        {
            DbContext = dbContext;
            Logger = logger;
        }

        // Routes can also be generated by attributes on controllers/actions.
        // This approach is more precise than defining route templates in Startup
        // but requires routes to be attributed individually
        // GET: api/Tasks
        [HttpGet]
        public async Task<IActionResult> Tasks([FromQuery] int? skip, [FromQuery] int? count, CancellationToken ct)
        {
            // Note that we need explicitly load related entities.
            // EF.Core does not support lazy loading like EF6 did.
            // https://docs.microsoft.com/en-us/ef/core/querying/related-data
            // Here, we use eager loading. See the Details method for an example of explicit loading
            //
            // No tracking since we won't be modifying these entities
            // http://stackoverflow.com/questions/12211680/what-difference-does-asnotracking-make
            var tasks = DbContext.Tasks
                            .Include(t => t.CategoryJoins)
                            .ThenInclude(x => x.Category)
                            .AsNoTracking();
            if (skip.HasValue) tasks = tasks.Skip(skip.Value);
            if (count.HasValue) tasks = tasks.Take(count.Value);

            var ret = (await tasks.ToArrayAsync(ct)).Select(CreateTaskDTO).ToArray();
            Logger.LogInformation("{Count} tasks queried", ret.Length);

            return Json(ret);
        }

        // GET: api/Tasks/{id}
        [ResponseCache(NoStore = true)]
        [HttpGet("{id}", Name = "TaskDetails")] // The name for this route means we can reference it elsewhere (like from Create, below)
        public async Task<IActionResult> Details(Guid id)
        {
            var task = await DbContext.Tasks.FindAsync(id);

            if (task != null)
            {
                // Explicitly query all joined categories and load them
                await DbContext.Entry(task)
                    .Collection(t => t.CategoryJoins)
                    .Query()
                    .Include(x => x.Category)
                    // .AsNoTracking()  // Note that we can NOT use AsNoTracking in explicit loading scenarios
                                        // (since EF has to fix-up the objects which are read-only in
                                        // AsNoTracking scenarios
                    .LoadAsync();

                Logger.LogInformation("Task {ID} retrieved", id);

                return Json(CreateTaskDTO(task));
            }
            else
            {
                Logger.LogWarning("Task {ID} not found", id);
                return NotFound();
            }
        }

        [HttpPost]
        // If a post is expected to only come from our views, an anti-forgery token should be used.
        // [ValidateAntiForgeryToken]
        // POST: api/Tasks
        public async Task<IActionResult> Create([FromQuery] string title, [FromQuery] string description, [FromQuery] IEnumerable<Guid> categories, CancellationToken ct)
        {
            if (title == null)
            {
                return BadRequest("Title required for new task");
            }

            var newTask = new TaskItem
            {
                Title = title,
                Description = description
            };
            DbContext.Tasks.Add(newTask);

            if (categories != null)
            {
                var validCategories = DbContext.TaskCategories.Where(cat => categories.Contains(cat.Id));

                foreach (var category in validCategories)
                {
                    DbContext.TaskCategoryJoins.Add(new TaskItemXTaskCategory { Category = category, Task = newTask });
                }
            }
            await DbContext.SaveChangesAsync(ct);

            Logger.LogInformation("Created task {ID}", newTask.Id);
            if (newTask.CategoryJoins.Any())
            {
                Logger.LogInformation("Task {ID} added to {count} categories", newTask.Id, newTask.CategoryJoins.Count);
            }
            return Created(Url.RouteUrl("TaskDetails", new { id = newTask.Id }), CreateTaskDTO(newTask));
        }

        // TODO - Do this with Automapper eventually.
        //        This is just a temporary solution
        //
        //        Mapping to a DTO is always a best practice,
        //        but is specifically needed in this case
        //        since the JSON serializer will hit
        //        circular references going from task item ->
        //        join entity -> task item
        private object CreateTaskDTO(TaskItem t)
        {
            return new
            {
                Id = t.Id,
                Title = t.Title,
                Description = t.Description,
                Completed = t.Completed,
                Created = t.Created,
                Complete = t.Complete,
                Categories = t.Categories.Select(c => new { c.Id, c.Title })
            };
        }
    }
}
